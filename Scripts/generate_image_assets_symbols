#!/usr/bin/env ruby

require "time"
require "fileutils"
require "digest/md5"

input = ["Sources/Resources/Icons.xcassets", "Sources/Resources/Assets.xcassets"]

output_filename = ARGV[0]
output_path = File.join(File.dirname(__FILE__), "..",  "Sources", "Resources")

temp_path = "/tmp/"

asset_folders = input.map do |name|
  unless File.extname(name) == ".xcassets"
    $stderr.puts "Only .xcassets bundles are supported"
  end
  name
end

names  = []
asset_folders.each do |folder|
  names += Dir.glob(File.join(folder, "/**/*.imageset")).map { |f| File.basename(f, File.extname(f)) }
end

names = names.sort

prelude = "//\n"
prelude << "//  Copyright Â© FINN.no AS, Inc. All rights reserved.\n"
prelude << "//\n"
prelude << "\n"
prelude << "// Generated by #{File.basename(__FILE__)} as a \"Run Script\" Build Phase\n"
prelude << "// WARNING: This file is autogenerated, do not modify by hand\n\n"

# objc
PREFIX = "FinniversImageAsset"

File.open(File.join(temp_path, "#{output_filename}.h"), "w") do |f|
  f.puts prelude
  f.puts "@import UIKit;\n\n"
  names.each do |name|
    f.puts "extern NSString *const #{PREFIX + name};\n"
  end

  f.puts "\n\n@interface UIImage (FinniversKit)\n"
  f.puts "+ (NSArray<NSString *> *)finniversImageNames;\n"
  f.puts "@end\n"
end

File.open(File.join(temp_path, "#{output_filename}.m"), "w") do |f|
  f.puts prelude
  f.puts "#import \"#{output_filename}.h\"\n\n"
  names.each do |name|
    f.puts "NSString *const #{PREFIX + name} = @\"#{name}\";\n"
  end

  f.puts "@implementation UIImage (FinniversKit)\n\n"
  f.puts "+ (NSArray<NSString *> *)finniversImageNames {\n"
  f.puts "    return @[\n"
  names.each do |name|
  f.puts "             #{PREFIX + name},\n"
  end
  f.puts "             ];\n"
  f.puts "}\n\n"
  f.puts "@end\n"
end

# swift

File.open(File.join(temp_path, "#{output_filename}.swift"), "w") do |f|
  f.puts prelude
  f.puts <<EOS
import UIKit

public extension UIImage {
    public convenience init(named imageAsset: FinniversImageAsset) {
        self.init(named: imageAsset.rawValue, in: FinniversKit.bundle, compatibleWith: nil)!
    }

    @objc public class func named(_ imageName: String) -> UIImage {
        return UIImage(named: imageName, in: FinniversKit.bundle, compatibleWith: nil)!
    }
}

public enum FinniversImageAsset: String {
EOS
  names.each do |name|
    casename = name.dup
    casename[0] = casename[0].downcase
    if name == casename
      f.puts "    case #{casename}\n"
    else
      f.puts "    case #{casename} = \"#{name}\"\n"
    end
  end

  f.puts "\n    public static var imageNames: [FinniversImageAsset] {\n"
  f.puts "        return [\n"
  names.each do |name|
    casename = name.dup
    casename[0] = casename[0].downcase
    f.puts "            .#{casename},\n"
  end
  f.puts "    ]\n"
  f.puts "  }\n"

  f.puts "}"
end

swiftNewDigest = Digest::MD5.hexdigest(File.read(File.join(temp_path, "#{output_filename}.swift")))
swiftOldDigest = Digest::MD5.hexdigest(File.read(File.join(output_path, "#{output_filename}.swift")))

objcNewDigest = Digest::MD5.hexdigest(File.read(File.join(temp_path, "#{output_filename}.m")))
objcOldDigest = Digest::MD5.hexdigest(File.read(File.join(output_path, "#{output_filename}.m")))

objcHeaderNewDigest = Digest::MD5.hexdigest(File.read(File.join(temp_path, "#{output_filename}.h")))
objcHeaderOldDigest = Digest::MD5.hexdigest(File.read(File.join(output_path, "#{output_filename}.h")))

if swiftNewDigest.eql? swiftOldDigest and objcNewDigest.eql? objcOldDigest and objcHeaderNewDigest.eql? objcHeaderOldDigest
  # No files replaced
else
  FileUtils.cp_r(File.join(temp_path, "#{output_filename}.swift"), File.join(output_path, "#{output_filename}.swift"), { remove_destination: true })
  FileUtils.cp_r(File.join(temp_path, "#{output_filename}.h"), File.join(output_path, "#{output_filename}.h"), { remove_destination: true })
  FileUtils.cp_r(File.join(temp_path, "#{output_filename}.m"), File.join(output_path, "#{output_filename}.m"), { remove_destination: true })
end
